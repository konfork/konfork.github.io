{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Konfork Declarative validations for Kotlin Validators Konfork allows you to easily build and maintain validators: val validateUser = Validator<UserProfile> { UserProfile::fullName { minLength(2) maxLength(100) } UserProfile::age ifPresent { minimum(0) maximum(150) } } val result = validateUser(someUser)","title":"Home"},{"location":"#konfork","text":"Declarative validations for Kotlin","title":"Konfork"},{"location":"#validators","text":"Konfork allows you to easily build and maintain validators: val validateUser = Validator<UserProfile> { UserProfile::fullName { minLength(2) maxLength(100) } UserProfile::age ifPresent { minimum(0) maximum(150) } } val result = validateUser(someUser)","title":"Validators"},{"location":"about/","text":"About Konfork is a fork of Konform. While Konform is an excellent project there were some important features missing: Custom error types Validation context Validator builders like lazy , eager and conditional Custom hints on required Besides this, the design philosophy was to not add a series of default validations (e.g. uuid() or email() ). This projects aim is to add these features and add many default validations, ready to be used.","title":"About"},{"location":"about/#about","text":"Konfork is a fork of Konform. While Konform is an excellent project there were some important features missing: Custom error types Validation context Validator builders like lazy , eager and conditional Custom hints on required Besides this, the design philosophy was to not add a series of default validations (e.g. uuid() or email() ). This projects aim is to add these features and add many default validations, ready to be used.","title":"About"},{"location":"concepts/","text":"Concepts Validator Validator Builder Constraint Builder fun Specification<Unit, String, String>.sandyPlanet() = addConstraint(\"must be a sandy planet\") { it == \"Tatooine\" || it == \"Arrakis\" }","title":"Concepts"},{"location":"concepts/#concepts","text":"","title":"Concepts"},{"location":"concepts/#validator","text":"","title":"Validator"},{"location":"concepts/#validator-builder","text":"","title":"Validator Builder"},{"location":"concepts/#constraint-builder","text":"fun Specification<Unit, String, String>.sandyPlanet() = addConstraint(\"must be a sandy planet\") { it == \"Tatooine\" || it == \"Arrakis\" }","title":"Constraint Builder"},{"location":"getting-started/","text":"Getting started Note that this is a newly forked project. Because of this I expect the API to be unstable the first couple of versions. Setup For multiplatform projects: kotlin { sourceSets { commonMain { dependencies { implementation(\"io.github.konfork:konfork-core:0.0.4\") } } } } For jvm-only projects add: dependencies { implementation(\"io.github.konfork:konfork-core-jvm:0.0.4\") } Writing your first Validator Most validators don't need any advanced features. Given a simple data class like data class UserProfile( val fullName: String, val age: Int? ) A possible validator can be as simple as: val validateUser = Validator<UserProfile> { UserProfile::fullName { minLength(2) maxLength(100) } UserProfile::age ifPresent { minimum(0) maximum(150) } } Using a validator To run the validator: val invalidUser = UserProfile(\"A\", -1) val result = validateUser(invalidUser) // result holds two errors: \"must have at least 2 characters\" and \"must be at least '0'\" The result can be used in several ways (see arrow module for pretty patterns): when (result) { is Valid -> result.value // value holds the user is Invalid -> result.errors // Get a list of all errors }","title":"Getting started"},{"location":"getting-started/#getting-started","text":"Note that this is a newly forked project. Because of this I expect the API to be unstable the first couple of versions.","title":"Getting started"},{"location":"getting-started/#setup","text":"For multiplatform projects: kotlin { sourceSets { commonMain { dependencies { implementation(\"io.github.konfork:konfork-core:0.0.4\") } } } } For jvm-only projects add: dependencies { implementation(\"io.github.konfork:konfork-core-jvm:0.0.4\") }","title":"Setup"},{"location":"getting-started/#writing-your-first-validator","text":"Most validators don't need any advanced features. Given a simple data class like data class UserProfile( val fullName: String, val age: Int? ) A possible validator can be as simple as: val validateUser = Validator<UserProfile> { UserProfile::fullName { minLength(2) maxLength(100) } UserProfile::age ifPresent { minimum(0) maximum(150) } }","title":"Writing your first Validator"},{"location":"getting-started/#using-a-validator","text":"To run the validator: val invalidUser = UserProfile(\"A\", -1) val result = validateUser(invalidUser) // result holds two errors: \"must have at least 2 characters\" and \"must be at least '0'\" The result can be used in several ways (see arrow module for pretty patterns): when (result) { is Valid -> result.value // value holds the user is Invalid -> result.errors // Get a list of all errors }","title":"Using a validator"}]}